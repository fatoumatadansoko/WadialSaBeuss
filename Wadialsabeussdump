.shadow-sm {
  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075); /* Légère ombre pour donner du relief */
}

.dropdown-item {
  display: flex;
  align-items: center;
}

.dot {
  height: 20px;
  width: 15px;
  background-color: green;
  border-radius: 50%;
  display: inline-block;
  margin-right: 10px;
}

.dropdown-item.active {
  background-color: transparent;
  font-weight: bold;
  color: purple; /* Couleur de sélection */
}

.dropdown-item:hover {
  background-color: #f8f9fa; /* Couleur au survol */
}


.container {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin-top: 0;
}

.card-container {
  flex: 1 1 300px;
  max-width: 300px;
}

.card {
  margin-top: 10px;
  width: 100%;
  height: auto; /* Ajuster la hauteur automatiquement en fonction du contenu */
  position: relative;
  overflow: visible; /* Assurer que tout le contenu soit visible */
}

.card-content {
  position: absolute;
  top: 50%; 
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  color: white;
  width: 80%;
}

.card img {
  width: 100%;
  height: auto; /* Laisser l'image ajuster sa propre hauteur */
  object-fit: cover;
  margin-left: 5px;
  margin-right: 5px;
  margin-top: 10px;
}

/* Styles pour les icônes */
.bi-pencil-square, .bi-send-fill, .bi-download {
  font-size: 1.5rem;
  color: rgb(77, 20, 20);
  cursor: pointer;
}

/* Alignement des icônes */
.icons {
  display: flex;
  justify-content: center;
  align-items: center;
}

.icons i {
  margin-right: 10px;
}

.icons i:last-child {
  margin-right: 0;
}





import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, throwError, catchError, tap } from 'rxjs';
import { BehaviorSubject} from 'rxjs';
import { apiurl } from './ApiUrl';
import { Router } from '@angular/router';
import { jwtDecode } from 'jwt-decode';



@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private isLoggedInSubject = new BehaviorSubject<boolean>(!!localStorage.getItem('token'));
  private http = inject(HttpClient);
  
  // Observable pour le statut de connexion
  isLoggedIn(): Observable<boolean> {
    return this.isLoggedInSubject.asObservable();
  }

  // Méthode pour se connecter
  login(identifiant: any): Observable<any> {
    return this.http.post(`${apiurl}/login`, identifiant).pipe(
      tap((response: any) => {
        if (response.token) {
          localStorage.setItem('token', response.token);
          localStorage.setItem('user', JSON.stringify(response.user));
          this.isLoggedInSubject.next(true); // Met à jour l'état de connexion
        }
      }),
      catchError((error) => {
        console.error('Login failed:', error);
        return throwError(error);
      })
    );
  }

  // Méthode pour se déconnecter
  logout(): Observable<any> {
    const token = localStorage.getItem('token');
  
    if (!token) {
      console.error('No authentication token found');
      return throwError('No authentication token found');
    }

    const headers = new HttpHeaders({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });

    return this.http.post(`${apiurl}/logout`, {}, { headers }).pipe(
      tap(() => {
        // Supprimer le token et informer que l'utilisateur est déconnecté
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        this.isLoggedInSubject.next(false); // Mise à jour de l'état de connexion
      }),
      catchError((error) => {
        if (error.status === 401) {
          console.error('Invalid or expired token, forced logout.');
          localStorage.removeItem('token');
          localStorage.removeItem('user');
          this.isLoggedInSubject.next(false); // Mise à jour de l'état de connexion
        }
        return throwError(error);
      })
    );
  }


  

 downloadCarteImage(carte: any): void {
  const cardElement = document.getElementById(`carte-${carte.id}`) as HTMLElement;
  if (cardElement) {
    html2canvas(cardElement, { scale: 2, useCORS: true }).then(canvas => {
      const imgData = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = imgData;
      a.download = `${carte.nom}.png`;
      a.click();
    }).catch(error => {
      console.error('Erreur lors de la capture de la carte :', error);
    });
  }
}







la dernier interceptor réaliser
import { HttpEvent, HttpHandlerFn, HttpHeaders, HttpRequest } from "@angular/common/http";
import { Observable } from "rxjs";
import { isPlatformBrowser } from '@angular/common';
import { inject, PLATFORM_ID } from '@angular/core';

export function authInterceptor(req: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> {
    const platformId = inject(PLATFORM_ID);
    let token: string = '';

    // Vérifier si nous sommes dans un environnement navigateur
    if (isPlatformBrowser(platformId)) {
        // Récupérer le token
        const tokenStr = localStorage.getItem('token');
        if (tokenStr) {
            try {
                token = JSON.parse(tokenStr);
            } catch (e) {
                // Si le token n'est pas au format JSON, l'utiliser tel quel
                token = tokenStr;
            }
        }

        // Si pas de token dans le localStorage direct, essayer de le récupérer depuis les infos utilisateur
        if (token) {
            const userStr = localStorage.getItem('user');
            if (userStr) {
                try {
                    const userInfo = JSON.parse(userStr);
                    if (userInfo && userInfo.token) {
                        token = userInfo.token;
                    }
                } catch (e) {
                    console.error('Erreur lors de la lecture des informations utilisateur:', e);
                }
            }
        }
    }

    // Si aucun token n'est trouvé, retourner la requête sans modification
    if (!token) {
        return next(req);
    }

    // Ajouter l'en-tête d'autorisation avec le token
    const headers = new HttpHeaders({
        'Authorization': `Bearer ${token}`,
        // Vous pouvez ajouter d'autres en-têtes si nécessaire
        'Content-Type': 'application/json'
    });

    // Cloner et modifier la requête pour inclure les nouveaux en-têtes
    const modifiedReq = req.clone({
        headers: headers
    });

    // Retourner la requête modifiée
    return next(modifiedReq);
}



configuration des interceptor










// src/app/services/demande.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { apiUrl } from './ApiUrl';

@Injectable({
  providedIn: 'root'
})
export class DemandeService {
  constructor(private http: HttpClient) {}

  // Méthode pour récupérer les demandes d'un prestataire
  getDemandesForPrestataire(prestataireId: number): Observable<any> {
    return this.http.get<any>(`${apiUrl}/prestataires/${prestataireId}/demandes`);
  }

//   approuverDemande(demandeId: number) {
//     return this.http.post(`${this.apiUrl}/demande/${demandeId}/approuver`, {});
//   }

// refuserDemande(demandeId: number): Observable<{ success: boolean; message?: string }> {
//     return this.http.post(`${this.apiUrl}/demande/${demandeId}/refuser`, {});
//   }
// }
approuverDemande(demandeId: number): Observable<{ success: boolean; message?: string }> {
  return this.http.put<{ success: boolean; message?: string }>(`${apiUrl}/prestataires/demandes/${demandeId}/accepter`, {});
}

refuserDemande(demandeId: number): Observable<{ success: boolean; message?: string }> {
  return this.http.put<{ success: boolean; message?: string }>(`${apiUrl}/prestataires/demandes/${demandeId}/refuser`, {});
}
}



import { PrestataireModel } from "./prestataire.model";

// Définir une énumération pour l'état
export enum EtatDemande {
    EN_ATTENTE = 'en_attente',
    APPROUVE = 'approuvée',
    REJETE = 'rejete'
}

export interface DemandePrestation {
    id?: number;
    user_id?: number;
    prestataire_id?: number;
    etat?: EtatDemande; // Utilisation de l'énumération
    createdAt?: Date;
    updatedAt?: Date;
    clientNom?: string; // Ajout du nom du client
    client: UserModel; //
}

export interface UserModel {
    id?: number;
    description?:string;
    nom?: string;
    email?: string;
    password?: string;
    adresse?: string;
    telephone?: string;
    statut?: "active";
    createdAt?: Date;
    updatedAt?: Date;
    logo?:string;
    prestataire?: PrestataireModel;
}


<app-header></app-header>
<div class="container">
  <h2>Demandes de Prestations</h2>

  <div *ngIf="demandes.length === 0">
    <p>Aucune demande trouvée pour ce prestataire.</p>
  </div>

  <table *ngIf="demandes.length > 0" class="table table-bordered table-hover">
    <thead class="table-white">
      <tr>
        <th scope="col">Numéro</th>
        <th scope="col">Client</th> <!-- Affichage du nom du client -->
        <th scope="col">Statut</th>
        <th scope="col">Actions</th> <!-- Nouvelle colonne pour les actions -->
      </tr>
    </thead>
    <tbody>
      <tr *ngFor="let demande of demandes">
        <td>{{ demande.id }}</td>
        <td>{{ demande.clientNom }}</td>
        <td>{{ demande.etat }}</td>
       
          <td>
            <i class="fas fa-check-circle text-success" *ngIf="demande.id"  (click)="approuverDemande(demande.id)" title="Approuver" style="cursor: pointer;"></i>
            <i class="fas fa-times-circle text-danger" *ngIf="demande.id" (click)="refuserDemande(demande.id)" title="Refuser" style="cursor: pointer; margin-left: 10px;"></i>
          </td>
      </tr>
    </tbody>
  </table>
</div>



/* Style pour les icônes dans le tableau */
table i {
  font-size: 24px; /* Taille de l'icône */
  cursor: pointer; /* Changer le curseur pour montrer que c'est cliquable */
  margin-right: 15px; /* Espacement entre les icônes */
  transition: color 0.3s ease; /* Transition pour un effet de survol */
}

/* Couleurs pour les icônes */
.text-success {
  color: #28a745; /* Couleur verte pour l'icône d'approbation */
}

.text-danger {
  color: #dc3545; /* Couleur rouge pour l'icône de rejet */
}

/* Effets au survol des icônes */
table i:hover {
  opacity: 0.7; /* Légère transparence au survol pour indiquer que c'est cliquable */
}

/* Styles supplémentaires si nécessaire */
.container {
  margin-top: 180px;
}

/* Table d'informations utilisateur */
.table {
  border-radius: 10px;
  overflow: hidden;
  margin-bottom: 20px;
}

th {
  font-weight: bold;
  text-transform: uppercase;
}

td {
  text-align: right;
}

/* Styles du body */
body {
  font-family: Arial, sans-serif;
  background-color: #f8f9fa;
}

/* Conteneur principal avec flexbox */
.main-container {
  display: flex; /* Aligne la sidebar et le contenu horizontalement */
}

.content {
  flex: 1; /* Prend tout l'espace disponible à droite de la sidebar */
  padding: 20px;
}

@media (max-width: 768px) {
  .content {
    padding: 10px;
  }

  .table th,
  .table td {
    font-size: 0.9rem;
  }
}


import { Component, OnInit, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { DemandeService } from '../../../Services/demande.service';
import { CommonModule, NgFor, NgIf } from '@angular/common';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { FooterComponent } from '../../Commun/footer/footer.component';
import { HeaderComponent } from '../../Commun/header/header.component';
import { UserService } from '../../../Services/users.service';
import { DemandePrestationService } from '../../../Services/demandePrestation.service';
import { PrestataireService } from '../../../Services/prestataire.service';
import { environment } from '../../../../environnements/environments';
import { UserModel } from '../../../Models/prestataire.model';
import { DemandePrestation, EtatDemande } from '../../../Models/demande_prestataires.model';
import Swal from 'sweetalert2';

@Component({
  selector: 'app-demande-list',
  standalone: true,
  imports: [HeaderComponent, FooterComponent, FormsModule, NgFor, NgIf,ReactiveFormsModule,CommonModule],
  templateUrl: './demande-list.component.html',
  styleUrls: ['./demande-list.component.scss'] // Correction : 'styleUrls' au lieu de 'styleUrl'
})
export class DemandeListComponent implements OnInit {
  prestataire: any; // Variable pour stocker les infos du prestataire connecté
  demandes: DemandePrestation[] = [];
  prestataire_id!: number; // Variable pour l'ID du prestataire
  user: any; // Variable pour stocker les infos de l'utilisateur connecté
  baseUrl: string = environment.apiurl;
  users: any[] = []; // Initialisez comme tableau vide
  // Utilisation de l'injection avec la méthode 'inject' (Angular >= 16)
  private demandeService = inject(DemandeService);
  private userService = inject(UserService);
  private demandePrestationService = inject(DemandePrestationService);
  private route = inject(ActivatedRoute);
  private prestataireService = inject(PrestataireService);

  ngOnInit(): void {
    this.loadPrestataireDemandes(); // Charge les demandes du prestataire connecté
    this.fetchUsers();
    

  }



 
  loadPrestataireDemandes(): void {
    const prestataire = localStorage.getItem('prestataire');

    if (prestataire) {
        const prestataireId = JSON.parse(prestataire).id;

        this.demandePrestationService.getDemandesByPrestataireId(prestataireId).subscribe(
            (response: any) => {
                if (response.success) {
                    this.demandes = response.prestataire.demandes;

                    // Assigner le nom du client directement depuis la réponse API
                    this.demandes.forEach(demande => {
                        demande.clientNom = demande.client ? demande.client.nom : 'Nom inconnu';
                    });

                    console.log('Demandes avec noms de clients:', this.demandes);

                } else {
                    console.error(response.message);
                }
            },
            (error) => {
                console.error('Erreur lors de la récupération des demandes', error);
            }
        );
    } else {
        console.error('Prestataire non trouvé dans le localStorage');
    }
}


  getUserProfile(): void {
    // if (typeof window !== 'undefined' && localStorage.getItem('prestataire')) {
    const prestataire = localStorage.getItem('prestataire');
    // const prestataire = JSON.parse(typeof window !== 'undefined' && localStorage.getItem('prestataire') || "{}");
    
    if (prestataire) {
        const prestataireId = JSON.parse(prestataire).id; // Récupère l'ID du client
      console.log(prestataireId);
    }
      this.userService.getProfile().subscribe(
        response => {
          console.log('Données de profil utilisateur:', response);
          this.user = response.data; // Stocke les données utilisateur renvoyées par l'API
        },
        error => {
          console.error('Erreur lors de la récupération des informations utilisateur:', error);
        }
      );
      
    }
  
    

   fetchUsers(): void {
    this.userService.getAllUser().subscribe(
      (response: any) => {
        console.log('Réponse complète:', response); // Vérifiez ici la structure
        if (response && Array.isArray(response)) {
          this.users = response.reverse(); // Assurez-vous d'utiliser la structure correcte
          console.log('Utilisateurs:', this.users); // Vérifiez si les utilisateurs sont bien affectés
        } else {
          console.error('Erreur: la réponse ne contient pas de données utilisateur');
        }
      },
      (error: any) => {
        console.error('Erreur lors de la récupération des utilisateurs:', error);
      }
    );
  }
 // Méthode pour approuver une demande
 approuverDemande(demandeId: number): void {
  this.demandeService.approuverDemande(demandeId).subscribe(
    (response: { success: boolean; message?: string }): void => {
      
      if (response.success) {
        const demande = this.demandes.find(d => d.id === demandeId);
        if (demande) {
          demande.etat = EtatDemande.APPROUVE; // Utilisation de l'énumération
          console.log('Demande approuvée avec succès.');
          // Afficher SweetAlert pour succès
          Swal.fire({
            title: 'Demande approuvée!',
            text: 'La demande a été approuvée avec succès.',
            icon: 'success',
            timer: 3000, // Ferme après 3 secondes
            showConfirmButton: false
          });
        }
      } else {
        console.error('Erreur lors de l\'approbation de la demande:', response.message);
        // Afficher SweetAlert pour erreur
        Swal.fire({
          title: 'Erreur',
          text: response.message || 'Une erreur est survenue.',
          icon: 'error',
          timer: 3000,
          showConfirmButton: false
        });
      }
    },
    error => {
      console.error('Erreur lors de l\'approbation de la demande:', error);
      // Afficher SweetAlert pour erreur
      Swal.fire({
        title: 'Erreur',
        text: 'Une erreur est survenue lors de l\'approbation de la demande.',
        icon: 'error',
        timer: 3000,
        showConfirmButton: false
      });
    }
  );
}

// Méthode pour refuser une demande
refuserDemande(demandeId: number): void {
  this.demandeService.refuserDemande(demandeId).subscribe(
    (response: { success: boolean; message?: string }): void => {
      if (response.success) {
        const demande = this.demandes.find(d => d.id === demandeId);
        if (demande) {
          demande.etat = EtatDemande.REJETE; // Utilisation de l'énumération
          console.log('Demande rejetée avec succès.');
          // Afficher SweetAlert pour succès
          Swal.fire({
            title: 'Demande rejetée!',
            text: 'La demande a été refusée avec succès.',
            icon: 'success',
            timer: 3000,
            showConfirmButton: false
          });
        }
      } else {
        console.error('Erreur lors du rejet de la demande:', response.message);
        // Afficher SweetAlert pour erreur
        Swal.fire({
          title: 'Erreur',
          text: response.message || 'Une erreur est survenue.',
          icon: 'error',
          timer: 3000,
          showConfirmButton: false
        });
      }
    },
    error => {
      console.error('Erreur lors du rejet de la demande:', error);
      // Afficher SweetAlert pour erreur
      Swal.fire({
        title: 'Erreur',
        text: 'Une erreur est survenue lors du rejet de la demande.',
        icon: 'error',
        timer: 3000,
        showConfirmButton: false
      });
    }
  );
}
}



// header.component.ts
import { CommonModule, isPlatformBrowser } from '@angular/common';
import { Component, OnDestroy, OnInit, PLATFORM_ID, Inject } from '@angular/core';
import { RouterLink, RouterLinkActive, RouterModule } from '@angular/router';
import { AuthService } from '../../../Services/auth.service';
import { Router } from '@angular/router';
import { Subscription } from 'rxjs';
import Swal from 'sweetalert2';

@Component({
  selector: 'app-header',
  standalone: true,
  imports: [
    CommonModule,
    RouterLink,
    RouterLinkActive,
    RouterModule
  ],
  templateUrl: './header.component.html',
  styleUrl: './header.component.scss'
})
export class HeaderComponent implements OnInit, OnDestroy {
  isLoggedIn: boolean = false;
  private authSubscription: Subscription = new Subscription();
  private tokenCheckInterval: any;
  private isBrowser: boolean;

  constructor(
    private authService: AuthService,
    private router: Router,
    @Inject(PLATFORM_ID) platformId: Object
  ) {
    this.isBrowser = isPlatformBrowser(platformId);
  }

  ngOnInit(): void {
    // Vérifier l'état initial de connexion uniquement côté navigateur
    if (this.isBrowser) {
      this.checkAuthStatus();

      // S'abonner aux changements d'état d'authentification
      this.authSubscription = this.authService.authStatus$.subscribe(
        (isLoggedIn: boolean) => {
          this.isLoggedIn = isLoggedIn;
        }
      );

      // Vérifier périodiquement la validité du token
      this.tokenCheckInterval = setInterval(() => {
        this.checkTokenValidity();
      }, 60000);
    }
  }

  private checkAuthStatus(): void {
    if (!this.isBrowser) return;

    const token = localStorage.getItem('token');
    if (token) {
      try {
        if (!this.authService.isTokenExpired(token)) {
          this.authService.updateAuthStatus(true);
        } else {
          this.handleExpiredToken();
        }
      } catch (error) {
        console.error('Erreur lors de la vérification du token:', error);
        this.handleExpiredToken();
      }
    } else {
      this.authService.updateAuthStatus(false);
    }
  }

  private checkTokenValidity(): void {
    if (!this.isBrowser) return;

    const token = localStorage.getItem('token');
    if (token && this.authService.isTokenExpired(token)) {
      this.handleExpiredToken();
    }
  }

  private handleExpiredToken(): void {
    if (!this.isBrowser) return;

    this.authService.updateAuthStatus(false);
    this.clearLocalStorage();
    this.router.navigate(['/login']);
    Swal.fire({
      title: 'Session expirée',
      text: 'Votre session a expiré. Veuillez vous reconnecter.',
      icon: 'warning',
      confirmButtonText: 'OK'
    });
  }

  private clearLocalStorage(): void {
    if (!this.isBrowser) return;
    
    localStorage.removeItem('token');
    localStorage.removeItem('user');
  }

  logout(): void {
    if (!this.isBrowser) return;

    Swal.fire({
      title: 'Déconnexion',
      text: 'Êtes-vous sûr de vouloir vous déconnecter ?',
      icon: 'question',
      showCancelButton: true,
      confirmButtonText: 'Oui',
      cancelButtonText: 'Non'
    }).then((result) => {
      if (result.isConfirmed) {
        this.authService.logout().subscribe({
          next: () => {
            this.handleLogoutSuccess();
          },
          error: (error) => {
            this.handleLogoutError(error);
          }
        });
      }
    });
  }

  private handleLogoutSuccess(): void {
    if (!this.isBrowser) return;

    this.clearLocalStorage();
    this.authService.updateAuthStatus(false);
    this.router.navigate(['/login']);
    Swal.fire({
      title: 'Déconnexion réussie',
      text: 'Vous avez été déconnecté avec succès.',
      icon: 'success',
      timer: 2000,
      showConfirmButton: false
    });
  }

  private handleLogoutError(error: any): void {
    if (!this.isBrowser) return;

    console.error('Erreur lors de la déconnexion:', error);
    this.clearLocalStorage();
    this.authService.updateAuthStatus(false);
    this.router.navigate(['/login']);
    Swal.fire({
      title: 'Erreur',
      text: 'Une erreur est survenue lors de la déconnexion.',
      icon: 'error'
    });
  }

  ngOnDestroy(): void {
    if (this.isBrowser) {
      this.authSubscription.unsubscribe();
      if (this.tokenCheckInterval) {
        clearInterval(this.tokenCheckInterval);
      }
    }
  }
}
